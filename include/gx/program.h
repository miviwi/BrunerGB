#pragma once

#include <gx/gx.h>
#include <gx/object.h>

#include <cassert>

#include <exception>
#include <stdexcept>
#include <string>
#include <vector>
#include <unordered_map>
#include <string_view>
#include <optional>
#include <tuple>

namespace brdrive {

// Forward declaration
class GLTexImageUnit;

class GLShader : public GLObject {
public:
  enum Type {
    Invalid,

    Vertex,
    TessControl, TessEvaluation,
    Geometry, Fragment,

    Compute,
  };

  enum : int {
    DefaultGLSLVersion = 330,
  };

  struct CompileError : public std::runtime_error {
    CompileError() :
      std::runtime_error("failed to compile() to GLShader!")
    { }
  };

  struct GLSLVersionRedefinitionError : std::runtime_error {
    GLSLVersionRedefinitionError() :
      std::runtime_error("attempted to redefine the shader's GLSL version!"
          " (more than one glslVersion() call was made")
    { }
  };

  struct InvalidDefineIdentifierError : public std::runtime_error {
    InvalidDefineIdentifierError() :
      std::runtime_error("the 'identifier' for define() can contain only"
          " alphanumeric characters [a-zA-Z0-9] and underscores [_]"
          " additionally it MUST NOT start with a number")
    { }
  };

  GLShader(Type type);
  GLShader(GLShader&& other);
  virtual ~GLShader();

  auto operator=(GLShader&& other) -> GLShader&;

  // Prepends:
  //      #version <ver>
  //   to the very start of the sources
  //  - This method can be called only ONCE
  //    on a given shader. Futher calls
  //    will cause exceptions to be thrown.
  //  - If glslVersion() doesn't get called
  //      #version <GLShader::DefaultGLSLVersion>
  //    will be prepended to the sources
  //    by default
  //  - 'ver' can be < 0 which inhibits
  //    adding the default version directive
  //  - If the 'src' passed to the first
  //    source() call starts with a #version
  //    directive, it will be swapped out
  //    with the one generated by this method
  auto glslVersion(int ver) -> GLShader&;

  // Appends 'src' to this shader's source code
  //   - The memory pointed to by 'src' MUST remain
  //     valid until compile() is called, otherwise
  //     UB/crashes WILL occur
  auto source(std::string_view src) -> GLShader&;

  // Defines a symbol by prepending -
  //     #define <identifier> [value]
  //   to the shader's source code
  //  - <identifier> is always a part
  //    of the prepended line, while
  //    [value] is optional, so leaving
  //    it out is allowed
  //  - If an <identifier> which uses
  //    disallowed characters is given -
  //    an exception will be thrown
  //  - It's recommended to add defines
  //    before the sources as the defines
  //    require prepending, which is a
  //    slow operation of the data
  //    structure used internally
  auto define(const char *identifier, const char *value = nullptr) -> GLShader&;

  // Must be called after appending all the sources
  auto compile() -> GLShader&;

  // Returns 'true' if the GLShader has been
  //   compiled sucessfully
  auto compiled() const -> bool;

  auto infoLog() const -> std::optional<std::string>;

protected:
  auto swap(GLShader& other) -> GLShader&;

  virtual auto doDestroy() -> GLObject& final;

private:
  enum StateFlags : u32 {
    VersionStateMask  = 0b00000011,
    VersionStateShift = 0,

    VersionStateUseDefault     = 0,
    VersionStateInhibitDefault = 1,
    VersionStateVersionGiven   = 2,

    DefinesStateMask  = 0b00000100,
    DefinesStateShift = 2,

    DefinesStateInsertingRequired = 1,
  };

  GLEnum type_;

  bool compiled_;

  // Initialized with 0, which means:
  //   - VersionStateUseDefault
  //   - !DefinesStateInsertingRequired
  u32 sources_state_flags_;

  // Initialized with DefaultGLSLVersion
  int version_;

  // 'sources_' stores std::string_view's so the data
  //   they point to must be owned by someone, in the
  //   case of sources that's the responsibility of
  //   the caller - on the other hand, because the
  //   the text of the #defines is generated by
  //   the GLShader itself, we need to keep their
  //   data in the shader object itself
  std::optional<std::vector<std::string>> defines_;

  std::vector<std::string_view> sources_;
};

class GLProgram : public GLObject {
public:
  using UniformLocation = int;

  enum : UniformLocation {
    InvalidLocation = -1,
  };

  enum UniformType {
    InvalidType,

    Int, UInt, Float,
    IVec2, UIVec2, Vec2,
    IVec3, UIVec3, Vec3,
    IVec4, UIVec4, Vec4,
    Mat3x3, Mat4x3, Mat4x4,

    TexImageUnit,
  };

  struct LinkError : public std::runtime_error {
    LinkError() :
      std::runtime_error("linking the GLProgram failed!")
    { }
  };

  struct UniformTypeError : public std::runtime_error {
    UniformTypeError() :
      std::runtime_error("attempted to upload a uniform with"
          " a different type than initially!")
    { }
  };

  GLProgram();
  GLProgram(GLProgram&& other);
  virtual ~GLProgram();

  auto operator=(GLProgram&& other) -> GLProgram&;

  auto attach(const GLShader& shader) -> GLProgram&;
  auto detach(const GLShader& shader) -> GLProgram&;

  // - Can be called only AFTER attach()'ing all shaders
  // - Must be called BEFORE the program is bound to the
  //   pipeline
  auto link() -> GLProgram&;
  // Returns 'true' if link() was previously
  //   called (and succeeded) on this program
  auto linked() const -> bool;

  // Returns a string containing error messages
  //   after a LinkError() is thrown
  auto infoLog() const -> std::optional<std::string>;

  // Bind the program to the pipeline
  //   - Can ONLY be called if linked() == true
  auto use() -> GLProgram&;
  
  auto uniform(const char *name, int i) -> GLProgram&;
  auto uniform(const char *name, float f) -> GLProgram&;
  auto uniform(const char *name, const GLTexImageUnit& tex_unit) -> GLProgram&;

  auto uniformVec(const char *name, float x, float y) -> GLProgram&;
  auto uniformVec(const char *name, float x, float y, float z) -> GLProgram&;

  auto uniformMat4x4(const char *name, const float *mat) -> GLProgram&;

protected:
  auto swap(GLProgram& other) -> GLProgram&;

  virtual auto doDestroy() -> GLObject& final;

private:
  using UniformLocationType = std::tuple<UniformLocation, UniformType>;

  auto uniformLocationType(const char *name, UniformType type) -> UniformLocationType;

  // Usage:
  //   has_dsa: always ARB::direct_state_access || EXT::direct_state_access
  //   fn_dsa:  pointer to direct state acces version of the upload function
  //      i.e. glProgramUniform*
  //   fn_non_dsa: pointer to NON dsa version of the function i.e. glUniform*
  //   location:   can be obtained from uniformLocationType()
  //   args:       the value(s) to be uploaded
  //
  template <typename FnDSA, typename FnNonDSA, typename... Args>
  auto uploadUniform(
      bool has_dsa, FnDSA fn_dsa, FnNonDSA fn_non_dsa,
      UniformLocation location, Args&&... args
    ) -> GLProgram&
  {
    assert(id_ != GLNullId);
    assert(linked_ &&
      "attempted to upload a uniform to a GLProgram which hasn't been link()'ed!");

    // Avoid causing OpenGL errors caused by uploading
    //   uniforms which were optimized out (unused)
    if(location == InvalidLocation) return *this;

    // Use direct state access if it's available...
    if(has_dsa) {
      fn_dsa(id_, location, args...);
    } else {     // ...and fall back to the old path otherwise
      use();

      fn_non_dsa(location, args...);
    }

    return *this;
  }

  bool linked_;

  // Lazy-initialized when uploading a uniform for the first time
  std::unordered_map<std::string, UniformLocationType> uniforms_;
};

}
